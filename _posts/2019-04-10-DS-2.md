---
layout: posts
title: "자료구조 세미나 2차"
slug: "190410-DS-2"
categories: general
--- 

### 1.스택

스택: 데이터를 일시적으로 저장하기 위한 자료구조. 가장 나중에 넣은 데이터를 가장 먼저 꺼낸다.
소위 "후입선출(LIFO, Last In First Out)"이라고 한다. 보통 push, pop을 하는 위치를 top이라고 하고, 스택의 가장 부분을 bottom이라고 한다. 
push: 스택에 데이터를 넣는다.  
pop: 스택에서 데이터를 꺼낸다. 
이 둘이 가장 기본적인 동작이다. 이 외에도 스택과 관련된 동작으로는 peek(맨 위에 있는 요소의 값을 봄), clear(스택을 초기화) 등이 있다. 어떤 언어로 어떻게 구현하느냐에 따라 당연히 갖고있는 동작(함수)이나 변수(ex: 스택에 있는 요소의 개수를 알려주는 length)도 다르다. 

### 2.큐

큐: 스택과 마찬가지로 데이터를 일시적으로 쌓아 놓은 구조. 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 소위 "선입선출(FIFO, First In First Out)"이다. 일상에서 볼 수 있는 예로는 은행 창구, 마트 등의 대기열이 있다. 데이터를 꺼내는 쪽을 front, 데이터를 넣는 쪽을 rear라고 한다. 
인큐: 큐에 데이터를 넣는다. 
디큐: 큐에서 데이터를 꺼낸다.  

전통적인 의미에서의 배열로 큐를 구현할 경우 인큐는 복잡도 O(1), 적은 비용으로 구현할 수 있다. 하지만 디큐는 두 번째 이후의 모든 요소를 하나씩 앞쪽으로 옮겨야 한다. 이 처리는 복잡도 O(n)이다. 보다 효율을 높이기 위해 나온 개념이 링 버퍼(ring buffer)이다. 

링 버퍼: 배열의 처음과 끝이 연결되어 있다고 보는 자료구조. 기본적으로 크기가 고정되어 있음을 전제로 한다.  논리적으로 어떤 요소가 첫 번째 요소이고 어떤 요소고 마지막 요소인지 식별하기 위한 변수가 front와 rear이다. (물리적 요소의 순서가 아니다) 일반 큐는 front가 고정되어 있고 rear만 변화하지만(변경시키지만), 링 버퍼를 이용한 큐는 front의 위치를 옮길 수 있기 때문에 모든 요소를 옮길 필요가 없다. 

배열로 큐를 구현할 때 링 버퍼를 이용하면 프론트와 리어 값을 업데이트하면서 인큐와 디큐를 수행하기 때문에 앞서 언급한 요소 이동 문제를 해결할 수 있다. 처리의 복잡도는 O(1)이다. 

프론트와 리어 값만으로는 큐에 데이터를 더 넣을 수 있는 상황인지 아닌지 100% 정확하게 판단할 수 없다. 프론트와 리어의 값이 동일 할 때, 큐는 비어있을 수도 있고 가득찬 상태일 수도 있다. 
(Cf) 프론트와 리어 둘 다 0이 아닌 값이면서 큐가 비어 있는 경우도 있다.) 
따라서 큐의 최대 용량(max)와 현재 데이터 개수(num)를 나타내는 변수가 있으면 이 두 변수를 비교하여 텅 빈 상태인지 가득찬 상태인지 구분할 수 있다. 인큐하여 레어 값이 1 증가했을 때 큐의 최대 용량 값인 max와 같아질 경우, 프론트 값을 배열의 처음인 0으로 변경해야 한다. 

링 버퍼는 **오래된 데이터를 버리는 용도**로 사용할 수 있다. 배열을 기반으로 링 버퍼를 사용해서 큐를 만들었다고 가정하자. 요소를 최대 n개 까지 저장할 수 있는 배열이라면, 이 배열에 계속해서 새로운 데이터가 들어온다면 가장 최근에 들어온 데이터 n개만 저장하고 오래된 데이터는 버리는 용도로 쓸 수 있다. 

기타) 덱: 양방향 대기열. doulbe ended queue. 시작과 끝 지점 양쪽에서 데이터를 인큐하거나 디큐할 수 있는 자료구조이다. 

